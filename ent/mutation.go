// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"simple-bank/ent/account"
	"simple-bank/ent/entry"
	"simple-bank/ent/predicate"
	"simple-bank/ent/transfer"
	"sync"
	"time"

	"entgo.io/ent"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccount  = "Account"
	TypeEntry    = "Entry"
	TypeTransfer = "Transfer"
)

// AccountMutation represents an operation that mutates the Account nodes in the graph.
type AccountMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	create_time     *time.Time
	update_time     *time.Time
	owner           *string
	balance         *int32
	addbalance      *int32
	currency        *string
	clearedFields   map[string]struct{}
	entries         map[uuid.UUID]struct{}
	removedentries  map[uuid.UUID]struct{}
	clearedentries  bool
	outbound        map[uuid.UUID]struct{}
	removedoutbound map[uuid.UUID]struct{}
	clearedoutbound bool
	inbound         map[uuid.UUID]struct{}
	removedinbound  map[uuid.UUID]struct{}
	clearedinbound  bool
	done            bool
	oldValue        func(context.Context) (*Account, error)
	predicates      []predicate.Account
}

var _ ent.Mutation = (*AccountMutation)(nil)

// accountOption allows management of the mutation configuration using functional options.
type accountOption func(*AccountMutation)

// newAccountMutation creates new mutation for the Account entity.
func newAccountMutation(c config, op Op, opts ...accountOption) *AccountMutation {
	m := &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountID sets the ID field of the mutation.
func withAccountID(id uuid.UUID) accountOption {
	return func(m *AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Account
		)
		m.oldValue = func(ctx context.Context) (*Account, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccount sets the old Account of the mutation.
func withAccount(node *Account) accountOption {
	return func(m *AccountMutation) {
		m.oldValue = func(context.Context) (*Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Account entities.
func (m *AccountMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *AccountMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *AccountMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AccountMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AccountMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *AccountMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AccountMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AccountMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetOwner sets the "owner" field.
func (m *AccountMutation) SetOwner(s string) {
	m.owner = &s
}

// Owner returns the value of the "owner" field in the mutation.
func (m *AccountMutation) Owner() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwner returns the old "owner" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldOwner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwner: %w", err)
	}
	return oldValue.Owner, nil
}

// ResetOwner resets all changes to the "owner" field.
func (m *AccountMutation) ResetOwner() {
	m.owner = nil
}

// SetBalance sets the "balance" field.
func (m *AccountMutation) SetBalance(i int32) {
	m.balance = &i
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *AccountMutation) Balance() (r int32, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldBalance(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds i to the "balance" field.
func (m *AccountMutation) AddBalance(i int32) {
	if m.addbalance != nil {
		*m.addbalance += i
	} else {
		m.addbalance = &i
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *AccountMutation) AddedBalance() (r int32, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *AccountMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetCurrency sets the "currency" field.
func (m *AccountMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *AccountMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *AccountMutation) ResetCurrency() {
	m.currency = nil
}

// AddEntryIDs adds the "entries" edge to the Entry entity by ids.
func (m *AccountMutation) AddEntryIDs(ids ...uuid.UUID) {
	if m.entries == nil {
		m.entries = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.entries[ids[i]] = struct{}{}
	}
}

// ClearEntries clears the "entries" edge to the Entry entity.
func (m *AccountMutation) ClearEntries() {
	m.clearedentries = true
}

// EntriesCleared reports if the "entries" edge to the Entry entity was cleared.
func (m *AccountMutation) EntriesCleared() bool {
	return m.clearedentries
}

// RemoveEntryIDs removes the "entries" edge to the Entry entity by IDs.
func (m *AccountMutation) RemoveEntryIDs(ids ...uuid.UUID) {
	if m.removedentries == nil {
		m.removedentries = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removedentries[ids[i]] = struct{}{}
	}
}

// RemovedEntries returns the removed IDs of the "entries" edge to the Entry entity.
func (m *AccountMutation) RemovedEntriesIDs() (ids []uuid.UUID) {
	for id := range m.removedentries {
		ids = append(ids, id)
	}
	return
}

// EntriesIDs returns the "entries" edge IDs in the mutation.
func (m *AccountMutation) EntriesIDs() (ids []uuid.UUID) {
	for id := range m.entries {
		ids = append(ids, id)
	}
	return
}

// ResetEntries resets all changes to the "entries" edge.
func (m *AccountMutation) ResetEntries() {
	m.entries = nil
	m.clearedentries = false
	m.removedentries = nil
}

// AddOutboundIDs adds the "outbound" edge to the Transfer entity by ids.
func (m *AccountMutation) AddOutboundIDs(ids ...uuid.UUID) {
	if m.outbound == nil {
		m.outbound = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.outbound[ids[i]] = struct{}{}
	}
}

// ClearOutbound clears the "outbound" edge to the Transfer entity.
func (m *AccountMutation) ClearOutbound() {
	m.clearedoutbound = true
}

// OutboundCleared reports if the "outbound" edge to the Transfer entity was cleared.
func (m *AccountMutation) OutboundCleared() bool {
	return m.clearedoutbound
}

// RemoveOutboundIDs removes the "outbound" edge to the Transfer entity by IDs.
func (m *AccountMutation) RemoveOutboundIDs(ids ...uuid.UUID) {
	if m.removedoutbound == nil {
		m.removedoutbound = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removedoutbound[ids[i]] = struct{}{}
	}
}

// RemovedOutbound returns the removed IDs of the "outbound" edge to the Transfer entity.
func (m *AccountMutation) RemovedOutboundIDs() (ids []uuid.UUID) {
	for id := range m.removedoutbound {
		ids = append(ids, id)
	}
	return
}

// OutboundIDs returns the "outbound" edge IDs in the mutation.
func (m *AccountMutation) OutboundIDs() (ids []uuid.UUID) {
	for id := range m.outbound {
		ids = append(ids, id)
	}
	return
}

// ResetOutbound resets all changes to the "outbound" edge.
func (m *AccountMutation) ResetOutbound() {
	m.outbound = nil
	m.clearedoutbound = false
	m.removedoutbound = nil
}

// AddInboundIDs adds the "inbound" edge to the Transfer entity by ids.
func (m *AccountMutation) AddInboundIDs(ids ...uuid.UUID) {
	if m.inbound == nil {
		m.inbound = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.inbound[ids[i]] = struct{}{}
	}
}

// ClearInbound clears the "inbound" edge to the Transfer entity.
func (m *AccountMutation) ClearInbound() {
	m.clearedinbound = true
}

// InboundCleared reports if the "inbound" edge to the Transfer entity was cleared.
func (m *AccountMutation) InboundCleared() bool {
	return m.clearedinbound
}

// RemoveInboundIDs removes the "inbound" edge to the Transfer entity by IDs.
func (m *AccountMutation) RemoveInboundIDs(ids ...uuid.UUID) {
	if m.removedinbound == nil {
		m.removedinbound = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removedinbound[ids[i]] = struct{}{}
	}
}

// RemovedInbound returns the removed IDs of the "inbound" edge to the Transfer entity.
func (m *AccountMutation) RemovedInboundIDs() (ids []uuid.UUID) {
	for id := range m.removedinbound {
		ids = append(ids, id)
	}
	return
}

// InboundIDs returns the "inbound" edge IDs in the mutation.
func (m *AccountMutation) InboundIDs() (ids []uuid.UUID) {
	for id := range m.inbound {
		ids = append(ids, id)
	}
	return
}

// ResetInbound resets all changes to the "inbound" edge.
func (m *AccountMutation) ResetInbound() {
	m.inbound = nil
	m.clearedinbound = false
	m.removedinbound = nil
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, account.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, account.FieldUpdateTime)
	}
	if m.owner != nil {
		fields = append(fields, account.FieldOwner)
	}
	if m.balance != nil {
		fields = append(fields, account.FieldBalance)
	}
	if m.currency != nil {
		fields = append(fields, account.FieldCurrency)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldCreateTime:
		return m.CreateTime()
	case account.FieldUpdateTime:
		return m.UpdateTime()
	case account.FieldOwner:
		return m.Owner()
	case account.FieldBalance:
		return m.Balance()
	case account.FieldCurrency:
		return m.Currency()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case account.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case account.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case account.FieldOwner:
		return m.OldOwner(ctx)
	case account.FieldBalance:
		return m.OldBalance(ctx)
	case account.FieldCurrency:
		return m.OldCurrency(ctx)
	}
	return nil, fmt.Errorf("unknown Account field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case account.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case account.FieldOwner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwner(v)
		return nil
	case account.FieldBalance:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case account.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountMutation) AddedFields() []string {
	var fields []string
	if m.addbalance != nil {
		fields = append(fields, account.FieldBalance)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case account.FieldBalance:
		return m.AddedBalance()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case account.FieldBalance:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case account.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case account.FieldOwner:
		m.ResetOwner()
		return nil
	case account.FieldBalance:
		m.ResetBalance()
		return nil
	case account.FieldCurrency:
		m.ResetCurrency()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.entries != nil {
		edges = append(edges, account.EdgeEntries)
	}
	if m.outbound != nil {
		edges = append(edges, account.EdgeOutbound)
	}
	if m.inbound != nil {
		edges = append(edges, account.EdgeInbound)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeEntries:
		ids := make([]ent.Value, 0, len(m.entries))
		for id := range m.entries {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeOutbound:
		ids := make([]ent.Value, 0, len(m.outbound))
		for id := range m.outbound {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeInbound:
		ids := make([]ent.Value, 0, len(m.inbound))
		for id := range m.inbound {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedentries != nil {
		edges = append(edges, account.EdgeEntries)
	}
	if m.removedoutbound != nil {
		edges = append(edges, account.EdgeOutbound)
	}
	if m.removedinbound != nil {
		edges = append(edges, account.EdgeInbound)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeEntries:
		ids := make([]ent.Value, 0, len(m.removedentries))
		for id := range m.removedentries {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeOutbound:
		ids := make([]ent.Value, 0, len(m.removedoutbound))
		for id := range m.removedoutbound {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeInbound:
		ids := make([]ent.Value, 0, len(m.removedinbound))
		for id := range m.removedinbound {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedentries {
		edges = append(edges, account.EdgeEntries)
	}
	if m.clearedoutbound {
		edges = append(edges, account.EdgeOutbound)
	}
	if m.clearedinbound {
		edges = append(edges, account.EdgeInbound)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	switch name {
	case account.EdgeEntries:
		return m.clearedentries
	case account.EdgeOutbound:
		return m.clearedoutbound
	case account.EdgeInbound:
		return m.clearedinbound
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	switch name {
	case account.EdgeEntries:
		m.ResetEntries()
		return nil
	case account.EdgeOutbound:
		m.ResetOutbound()
		return nil
	case account.EdgeInbound:
		m.ResetInbound()
		return nil
	}
	return fmt.Errorf("unknown Account edge %s", name)
}

// EntryMutation represents an operation that mutates the Entry nodes in the graph.
type EntryMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	create_time    *time.Time
	update_time    *time.Time
	amount         *int32
	addamount      *int32
	clearedFields  map[string]struct{}
	account        *uuid.UUID
	clearedaccount bool
	done           bool
	oldValue       func(context.Context) (*Entry, error)
	predicates     []predicate.Entry
}

var _ ent.Mutation = (*EntryMutation)(nil)

// entryOption allows management of the mutation configuration using functional options.
type entryOption func(*EntryMutation)

// newEntryMutation creates new mutation for the Entry entity.
func newEntryMutation(c config, op Op, opts ...entryOption) *EntryMutation {
	m := &EntryMutation{
		config:        c,
		op:            op,
		typ:           TypeEntry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntryID sets the ID field of the mutation.
func withEntryID(id uuid.UUID) entryOption {
	return func(m *EntryMutation) {
		var (
			err   error
			once  sync.Once
			value *Entry
		)
		m.oldValue = func(ctx context.Context) (*Entry, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Entry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntry sets the old Entry of the mutation.
func withEntry(node *Entry) entryOption {
	return func(m *EntryMutation) {
		m.oldValue = func(context.Context) (*Entry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Entry entities.
func (m *EntryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *EntryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *EntryMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *EntryMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Entry entity.
// If the Entry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *EntryMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *EntryMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *EntryMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Entry entity.
// If the Entry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *EntryMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetAmount sets the "amount" field.
func (m *EntryMutation) SetAmount(i int32) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *EntryMutation) Amount() (r int32, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Entry entity.
// If the Entry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryMutation) OldAmount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *EntryMutation) AddAmount(i int32) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *EntryMutation) AddedAmount() (r int32, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *EntryMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetAccountID sets the "account" edge to the Account entity by id.
func (m *EntryMutation) SetAccountID(id uuid.UUID) {
	m.account = &id
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *EntryMutation) ClearAccount() {
	m.clearedaccount = true
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *EntryMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountID returns the "account" edge ID in the mutation.
func (m *EntryMutation) AccountID() (id uuid.UUID, exists bool) {
	if m.account != nil {
		return *m.account, true
	}
	return
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *EntryMutation) AccountIDs() (ids []uuid.UUID) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *EntryMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// Op returns the operation name.
func (m *EntryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Entry).
func (m *EntryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntryMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, entry.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, entry.FieldUpdateTime)
	}
	if m.amount != nil {
		fields = append(fields, entry.FieldAmount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entry.FieldCreateTime:
		return m.CreateTime()
	case entry.FieldUpdateTime:
		return m.UpdateTime()
	case entry.FieldAmount:
		return m.Amount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entry.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case entry.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case entry.FieldAmount:
		return m.OldAmount(ctx)
	}
	return nil, fmt.Errorf("unknown Entry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entry.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case entry.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case entry.FieldAmount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Entry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntryMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, entry.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case entry.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case entry.FieldAmount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Entry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Entry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntryMutation) ResetField(name string) error {
	switch name {
	case entry.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case entry.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case entry.FieldAmount:
		m.ResetAmount()
		return nil
	}
	return fmt.Errorf("unknown Entry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.account != nil {
		edges = append(edges, entry.EdgeAccount)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case entry.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedaccount {
		edges = append(edges, entry.EdgeAccount)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntryMutation) EdgeCleared(name string) bool {
	switch name {
	case entry.EdgeAccount:
		return m.clearedaccount
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntryMutation) ClearEdge(name string) error {
	switch name {
	case entry.EdgeAccount:
		m.ClearAccount()
		return nil
	}
	return fmt.Errorf("unknown Entry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntryMutation) ResetEdge(name string) error {
	switch name {
	case entry.EdgeAccount:
		m.ResetAccount()
		return nil
	}
	return fmt.Errorf("unknown Entry edge %s", name)
}

// TransferMutation represents an operation that mutates the Transfer nodes in the graph.
type TransferMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	create_time        *time.Time
	update_time        *time.Time
	amount             *int32
	addamount          *int32
	clearedFields      map[string]struct{}
	fromAccount        *uuid.UUID
	clearedfromAccount bool
	toAccount          *uuid.UUID
	clearedtoAccount   bool
	done               bool
	oldValue           func(context.Context) (*Transfer, error)
	predicates         []predicate.Transfer
}

var _ ent.Mutation = (*TransferMutation)(nil)

// transferOption allows management of the mutation configuration using functional options.
type transferOption func(*TransferMutation)

// newTransferMutation creates new mutation for the Transfer entity.
func newTransferMutation(c config, op Op, opts ...transferOption) *TransferMutation {
	m := &TransferMutation{
		config:        c,
		op:            op,
		typ:           TypeTransfer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransferID sets the ID field of the mutation.
func withTransferID(id uuid.UUID) transferOption {
	return func(m *TransferMutation) {
		var (
			err   error
			once  sync.Once
			value *Transfer
		)
		m.oldValue = func(ctx context.Context) (*Transfer, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Transfer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransfer sets the old Transfer of the mutation.
func withTransfer(node *Transfer) transferOption {
	return func(m *TransferMutation) {
		m.oldValue = func(context.Context) (*Transfer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransferMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransferMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Transfer entities.
func (m *TransferMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *TransferMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *TransferMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TransferMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TransferMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TransferMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TransferMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TransferMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetAmount sets the "amount" field.
func (m *TransferMutation) SetAmount(i int32) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *TransferMutation) Amount() (r int32, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldAmount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *TransferMutation) AddAmount(i int32) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *TransferMutation) AddedAmount() (r int32, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *TransferMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetFromAccountID sets the "fromAccount" edge to the Account entity by id.
func (m *TransferMutation) SetFromAccountID(id uuid.UUID) {
	m.fromAccount = &id
}

// ClearFromAccount clears the "fromAccount" edge to the Account entity.
func (m *TransferMutation) ClearFromAccount() {
	m.clearedfromAccount = true
}

// FromAccountCleared reports if the "fromAccount" edge to the Account entity was cleared.
func (m *TransferMutation) FromAccountCleared() bool {
	return m.clearedfromAccount
}

// FromAccountID returns the "fromAccount" edge ID in the mutation.
func (m *TransferMutation) FromAccountID() (id uuid.UUID, exists bool) {
	if m.fromAccount != nil {
		return *m.fromAccount, true
	}
	return
}

// FromAccountIDs returns the "fromAccount" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FromAccountID instead. It exists only for internal usage by the builders.
func (m *TransferMutation) FromAccountIDs() (ids []uuid.UUID) {
	if id := m.fromAccount; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFromAccount resets all changes to the "fromAccount" edge.
func (m *TransferMutation) ResetFromAccount() {
	m.fromAccount = nil
	m.clearedfromAccount = false
}

// SetToAccountID sets the "toAccount" edge to the Account entity by id.
func (m *TransferMutation) SetToAccountID(id uuid.UUID) {
	m.toAccount = &id
}

// ClearToAccount clears the "toAccount" edge to the Account entity.
func (m *TransferMutation) ClearToAccount() {
	m.clearedtoAccount = true
}

// ToAccountCleared reports if the "toAccount" edge to the Account entity was cleared.
func (m *TransferMutation) ToAccountCleared() bool {
	return m.clearedtoAccount
}

// ToAccountID returns the "toAccount" edge ID in the mutation.
func (m *TransferMutation) ToAccountID() (id uuid.UUID, exists bool) {
	if m.toAccount != nil {
		return *m.toAccount, true
	}
	return
}

// ToAccountIDs returns the "toAccount" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ToAccountID instead. It exists only for internal usage by the builders.
func (m *TransferMutation) ToAccountIDs() (ids []uuid.UUID) {
	if id := m.toAccount; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetToAccount resets all changes to the "toAccount" edge.
func (m *TransferMutation) ResetToAccount() {
	m.toAccount = nil
	m.clearedtoAccount = false
}

// Op returns the operation name.
func (m *TransferMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Transfer).
func (m *TransferMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransferMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, transfer.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, transfer.FieldUpdateTime)
	}
	if m.amount != nil {
		fields = append(fields, transfer.FieldAmount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransferMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transfer.FieldCreateTime:
		return m.CreateTime()
	case transfer.FieldUpdateTime:
		return m.UpdateTime()
	case transfer.FieldAmount:
		return m.Amount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransferMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transfer.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case transfer.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case transfer.FieldAmount:
		return m.OldAmount(ctx)
	}
	return nil, fmt.Errorf("unknown Transfer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransferMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transfer.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case transfer.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case transfer.FieldAmount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Transfer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransferMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, transfer.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransferMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case transfer.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransferMutation) AddField(name string, value ent.Value) error {
	switch name {
	case transfer.FieldAmount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Transfer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransferMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransferMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransferMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Transfer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransferMutation) ResetField(name string) error {
	switch name {
	case transfer.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case transfer.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case transfer.FieldAmount:
		m.ResetAmount()
		return nil
	}
	return fmt.Errorf("unknown Transfer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransferMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.fromAccount != nil {
		edges = append(edges, transfer.EdgeFromAccount)
	}
	if m.toAccount != nil {
		edges = append(edges, transfer.EdgeToAccount)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransferMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transfer.EdgeFromAccount:
		if id := m.fromAccount; id != nil {
			return []ent.Value{*id}
		}
	case transfer.EdgeToAccount:
		if id := m.toAccount; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransferMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransferMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransferMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfromAccount {
		edges = append(edges, transfer.EdgeFromAccount)
	}
	if m.clearedtoAccount {
		edges = append(edges, transfer.EdgeToAccount)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransferMutation) EdgeCleared(name string) bool {
	switch name {
	case transfer.EdgeFromAccount:
		return m.clearedfromAccount
	case transfer.EdgeToAccount:
		return m.clearedtoAccount
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransferMutation) ClearEdge(name string) error {
	switch name {
	case transfer.EdgeFromAccount:
		m.ClearFromAccount()
		return nil
	case transfer.EdgeToAccount:
		m.ClearToAccount()
		return nil
	}
	return fmt.Errorf("unknown Transfer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransferMutation) ResetEdge(name string) error {
	switch name {
	case transfer.EdgeFromAccount:
		m.ResetFromAccount()
		return nil
	case transfer.EdgeToAccount:
		m.ResetToAccount()
		return nil
	}
	return fmt.Errorf("unknown Transfer edge %s", name)
}
